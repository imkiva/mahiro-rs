//
// Created by intellij-pest on 2020-04-13
// grammar
// Author: kiva
//

program = { SOI ~ (WHITESPACE | COMMENT | decl | stmt)* ~ EOI }

decl = { import_decl | module_decl | fn_decl | struct_decl }

import_decl = { "import" ~ mod_name ~ ("as" ~ id)? }
module_decl = { "module" ~ id ~ "where" }

// statement
stmt = { primary_stmt ~ SEMI? }
primary_stmt = { return_stmt
               | let_stmt
               | loop_control
               | assign_stmt
               | expr
               }

assign_stmt = { id ~ assign_op ~ expr }
assign_op = { "=" | "+=" | "-=" | "*=" | "/=" | "%=" }

// var
let_stmt = { "let" ~ pattern ~ "=" ~ expr }
pattern = { maybe_typed_id
          | "(" ~ maybe_typed_params ~ ")"
          }

// func
fn_decl = { "fn" ~ id ~ "(" ~ typed_params ~ ")" ~ fn_body }
fn_body = { "{" ~ common_body ~ "}"
          | "=" ~ expr
          }

// struct
struct_decl = { "struct" ~ id ~ "{" ~ struct_field* ~ "}" }
struct_field = { typed_id ~ "," }

common_body = { stmt* }

// return
return_stmt = { "return" ~ expr? }

// expr
expr = { if_expr
       | while_expr
       | loop_expr
       | for_expr
       | question_expr
       }

// if
if_expr = { "if" ~ expr ~ "{" ~ common_body ~ "}" ~ ("else" ~ "{" ~ common_body ~ "}")? }

// while
while_expr = { "while" ~ expr ~ "{" ~ common_body ~ "}" }

// loop
loop_expr = { "loop" ~ "{" ~ common_body ~ "}" }

// break/continue
loop_control = { break_ | continue_ }
break_ = { "break" ~ expr? }
continue_ = { "continue" }

// for
for_expr = { "for" ~ id ~ "in" ~ expr ~ "{" ~ common_body ~ "}" }

// we must ensure that the expr after "?" should be:
// [primary_prefix, mapping]
question_expr = { logic_or_expr ~ "?"? }

// level 6
logic_or_expr = { logic_and_expr ~ ("||" ~ logic_and_expr)* }

// level 7
logic_and_expr = { relation_expr ~ ("&&" ~ relation_expr)* }

// level 9
relation_expr = { add_expr ~ (relation_op ~ add_expr)* }
relation_op = { ">=" | "<=" | "==" | "!=" | "<" | ">" }

// level 10
add_expr = { mul_expr ~ (add_op ~ mul_expr)* }
add_op = { "+" | "-" }

// level 11
mul_expr = { mod_expr ~ (mul_op ~ mod_expr)* }
mul_op = { "*" | "/" }

// level 12
mod_expr = { unary_expr ~ (mod_op ~ unary_expr)* }
mod_op = { "%" }

unary_expr = { unary_op ~ expr
             | primary_expr
             }
unary_op = { not_op | add_op }
not_op = { "!" }

primary_expr = { primary_prefix ~ primary_postfix* }
primary_prefix = { "(" ~ expr ~ ("," ~ expr)* ~ ")"
                 | literal
                 | lambda
                 | id
                 }
primary_postfix = { apply
                  | member_apply
                  | index
                  }

apply = { "(" ~ args ~ ")" }
member_apply = { "." ~ id ~ apply? }
index = { "[" ~ expr ~ "]" }

lambda = { "|" ~ params ~ "|" ~ lambda_body }
lambda_body = { expr | "{" ~ common_body ~ "}" }

literal = { int_lit
          | float_lit
          | bool_lit
          | string_lit
          | char_lit
          | array_lit
          }

int_lit = $ { number_dec }
float_lit = $ { number_float }

number_dec = _ { ("+" | "-")? ~ ASCII_DIGIT+ }

number_float = _ { number_dec ~ "." ~ number_dec }

string_lit = $ { "\"" ~ (escape | (!("\\" | "\"") ~ ANY)+)* ~ "\""}

char_lit = $ { "\'" ~ (escape | (!("\\" | "\'") ~ ANY)+) ~ "\'"}

array_lit = { "[" ~ args ~ "]" }

bool_lit = { "true" | "false" }

id = $ { (ASCII_ALPHA | UNDERLINE | "$") ~ (ASCII_ALPHANUMERIC | UNDERLINE | "$")* }

escape = _{ "\\\\"
          | "\\\""
          | "\\'"
          | "\\n"
          | "\\r"
          | "\\t"
          | "\\a"
          | "\\b"
          | "\\f"
          | "\\v"
          | "\\0"
          }

typed_id = { id ~ ":" ~ id }
maybe_typed_id = { id ~ (":" ~ id)? }
params = { id ~ ("," ~ id)* }
typed_params = { typed_id ~ ("," ~ typed_id)* }
maybe_typed_params = { maybe_typed_id ~ ("," ~ maybe_typed_id)* }
mod_name = { id ~ ("." ~ id)* }
args = { (expr ~ ",")* }

UNDERLINE = _ { "_" }

SEMI = _ { ";" }

WHITESPACE = _ { " "
               | "\t"
               | WHITE_SPACE
               | NEWLINE
               }

COMMENT = _ { "#" ~ (!NEWLINE ~ ANY)* ~ NEWLINE?
            | "@charset" ~ (!NEWLINE ~ ANY)+ ~ NEWLINE?
            }
