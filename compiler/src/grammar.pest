//
// Created by intellij-pest on 2020-04-13
// grammar
// Author: kiva
//

program = { SOI ~ (WHITESPACE | COMMENT | header | stmt)* ~ EOI }

header = { using_decl | import_decl | package_decl }

using_decl = { "using" ~ mod_name }
import_decl = { "import" ~ mod_name ~ ("as" ~ id)? }
package_decl = { "package" ~ id }

// statement
stmt = { primary_stmt ~ SEMI? | cross_line_stmt }
cross_line_stmt = { "@begin" ~ stmt ~ "@end"}
primary_stmt = { throw_stmt
               | return_stmt
               | var_decl
               | func_decl
               | struct_decl
               | namespace_decl
               | block_decl
               | if_stmt
               | while_stmt
               | switch_stmt
               | for_stmt
               | for_each_stmt
               | loop_until_stmt
               | loop_control
               | try_stmt
               | expr_stmt
               }

expr_stmt = { primary_prefix ~ primary_postfix+
            }

// var
var_kw = _ { "var" | "constant" | "const" }
var_decl = { var_kw ~ var_init ~ ("," ~ var_init)* }
var_init = { id ~ "=" ~ expr
           | "(" ~ params ~ ")" ~ "=" ~ expr
           }

// func
func_decl = { "function" ~ id ~ callable_params ~ "override"? ~ common_body ~ "end" }

// namespace
namespace_decl = { "namespace" ~ id ~ common_body ~ "end" }

// struct
struct_kw = _ { "struct" | "class" }
struct_decl = { struct_kw ~ id ~ ("extends" ~ expr)? ~ struct_body ~ "end" }
struct_body = { (var_decl | func_decl)* }

common_body = { stmt* }

// return
return_stmt = { "return" ~ expr? }
// throw
throw_stmt = { "throw" ~ expr }

// try
try_stmt = { "try" ~ common_body ~ "catch" ~ id ~ common_body ~ "end" }

// if
if_stmt = { "if" ~ expr ~ SEMI? ~ common_body ~ SEMI? ~ ("else" ~ common_body)? ~ SEMI? ~ "end" }

// switch
switch_stmt = { "switch" ~ expr ~ switch_case* ~ "end" }
switch_case = { default_case | sth_case }
sth_case = { "case" ~ expr ~ SEMI? ~ ("end" | common_body ~ "end") }
default_case = { "default" ~ SEMI? ~ ("end" | common_body ~ "end") }

// while
while_stmt = { "while" ~ expr ~ common_body ~ "end" }

// loop
loop_until_stmt = { "loop" ~ common_body ~ loop_until_end }
loop_until_end = _ { "until" ~ expr | "end" }

// break/continue
loop_control = { break_ | continue_ }
break_ = { "break" }
continue_ = { "continue" }

// for
for_stmt = { "for" ~ id ~ for_header ~ for_body }
for_each_stmt = { "foreach" ~ id ~ for_each_header ~ for_body }
for_header = _ { "=" ~ expr ~ "," ~ expr ~ "," ~ expr }
for_each_header = _ { "in" ~ expr }
for_body = { "do" ~ stmt | common_body ~ "end" }

// block
block_decl = { "block" ~ common_body ~ "end" }

// expr
expr = { ternary_expr }

// we must ensure that the expr after "?" should be:
// [primary_prefix, mapping]
ternary_expr = { logic_or_expr ~ ("?" ~ expr)? }

// level 6
logic_or_expr = { logic_and_expr ~ (or_op ~ logic_and_expr)* }
// level 7
logic_and_expr = { relation_expr ~ (and_op ~ relation_expr)* }
and_op = { "and" | "&&" }
or_op = { "or" | "||" }

// level 9
relation_expr = { add_expr ~ (relation_op ~ add_expr)* }
relation_op = { ">=" | "<=" | "==" | "!=" | "<" | ">" }

// level 10
add_expr = { mul_expr ~ (add_op ~ mul_expr)* }
add_op = { "+" | "-" }

// level 11
mul_expr = { pow_expr ~ (mul_op ~ pow_expr)* }
mul_op = { "*" | "/" }

// level 12
pow_expr = { unary_expr ~ (pow_op ~ unary_expr)* }
pow_op = { "^" | "%" }

unary_expr = { unary_op ~ expr
             | primary_expr
             }
unary_op = { not_op | add_op | deref_op | "typeid" | "new" | "gcnew" }
not_op = { "not" | "!" }
deref_op = { "*" }

primary_expr = { primary_prefix ~ primary_postfix* }
primary_prefix = { "(" ~ expr ~ ("," ~ expr)* ~ ")"
                 | literal
                 | lambda
                 | id
                 }
primary_postfix = { apply
                  | index_access
                  | member_access
                  | mapping
                  | assign
                  | flatten
                  }

apply = { "(" ~ args? ~ ")" }
index_access = { "[" ~ expr ~ "]" }
member_access = { member_access_op ~ id }
member_access_op = _ { "." | "->" }
mapping = { ":" ~ expr }
assign = { assign_op ~ expr }
assign_op = { "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" }
flatten = { "..." }

lambda = { "[" ~ params? ~ "]" ~ callable_params ~ "->" ~ expr }

literal = { number_lit
          | bool_lit
          | null_lit
          | string_lit
          | char_lit
          | array_lit
          }

null_lit = { "null" }

number_lit = $ { number_float
               | number_dec
               }

number_dec = _ { ("+" | "-")? ~ ASCII_DIGIT+ }

number_float = _ { number_dec ~ "." ~ number_dec }

string_lit = $ { "\"" ~ (escape | (!("\\" | "\"") ~ ANY)+)* ~ "\""}

char_lit = $ { "\'" ~ (escape | (!("\\" | "\'") ~ ANY)+) ~ "\'"}

array_lit = { "{" ~ args? ~ "}" }

bool_lit = { "true" | "false" }

id = $ { !"end" ~ (ASCII_ALPHA | UNDERLINE | "$") ~ (ASCII_ALPHANUMERIC | UNDERLINE | "$")* }

escape = _{ "\\\\"
          | "\\\""
          | "\\'"
          | "\\n"
          | "\\r"
          | "\\t"
          | "\\a"
          | "\\b"
          | "\\f"
          | "\\v"
          | "\\0"
          }

params = { id ~ ("," ~ id)* }
varargs_param = { "..." ~ id }
mod_name = { id ~ ("." ~ id)* }
args = { expr ~ ("," ~ expr)* }
callable_params = { "(" ~ params? ~ (","? ~ varargs_param)? ~ ")" }

UNDERLINE = _ { "_" }

SEMI = _ { ";" }

WHITESPACE = _ { " "
               | "\t"
               | WHITE_SPACE
               | NEWLINE
               }

COMMENT = _ { "#" ~ (!NEWLINE ~ ANY)* ~ NEWLINE?
            | "@charset" ~ (!NEWLINE ~ ANY)+ ~ NEWLINE?
            }
